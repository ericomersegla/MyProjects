# -*- coding: utf-8 -*-
"""MON_TRAVAIL_DIRIG√â_StrATer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uoYcL8J1F5Z2Wrx4cIwZlDrSh-LdEnnP
"""

import pandas as pd
import numpy as np
import statsmodels.api as sm
import seaborn as sns
import matplotlib.pyplot as plt


from sklearn.impute import SimpleImputer
from statsmodels.formula.api import poisson
from statsmodels.formula.api import glm
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# importer la base de donn√©es
data = pd.read_excel('/content/Data_StrATer.xlsx')

# point global du nombre de ligne et de colonne.
print(data.shape)

# Liste du nom des colonnes.
print(data.keys())

# Categorisation par type variable

data_types = data.dtypes
numeric_columns = [col for col in data.columns if data[col].dtype in ['int64', 'float64']]
categorical_columns = [col for col in data.columns if data[col].dtype == 'object']

print("Variables num√©riques:", numeric_columns)
print("Variables cat√©goriques:", categorical_columns)

# Obtenir un r√©sum√© des valeurs manquantes dans chaque colonne
data.isnull().sum()

# Obtention de statistiques descriptives pour les variables num√©riques
data.describe().transpose()

# Obtention de statistiques descriptives pour les variables cat√©goriques
data.describe(include=['object']).transpose()

#Traittement des valeurs manquantes :: suppression des lignes pour toutes les variables manquantes

data.dropna(subset=numeric_columns, inplace=True)

# verification et control de correction par rapport aux valeurs manquantes
data.isnull().sum()

# point global du nombre de ligne et de colonne apres traitement des valeurs manquantes
print(data.shape)

# Transfornation de la varialle categorielle saison en variable binaire
data_mod=pd.get_dummies(data, columns=['Saison'])
data_mod

print(data_mod.keys())

# Trac√© de la courbe du rendement Moy_ ZC025YR:
plt.figure(figsize=(10, 5))
plt.plot(data['Moy_ ZC025YR'], label='Moy_ ZC025YR')
plt.title('Graphique du rendement de obligations zero coupon de maturit√© 3 mois')
plt.xlabel('index')
plt.ylabel('Valeur')
plt.legend()
plt.grid(True)
plt.show()

# Trac√© de la courbe du rendement Moy_ ZC050YR:
plt.figure(figsize=(10, 5))
plt.plot(data['Moy_ ZC050YR'], label='Moy_ ZC050YR')
plt.title('Graphique du rendement de obligations zero coupon de maturit√© 6 mois')
plt.xlabel('index')
plt.ylabel('Valeur')
plt.legend()
plt.grid(True)
plt.show()

# Trac√© de la courbe du rendement Moy_ ZC075YR:
plt.figure(figsize=(10, 5))
plt.plot(data['Moy_ ZC075YR'], label='Moy_ ZC075YR')
plt.title('Graphique du rendement de obligations zero coupon de maturit√© 9 mois')
plt.xlabel('index')
plt.ylabel('Valeur')
plt.legend()
plt.grid(True)
plt.show()

# Trac√© de la courbe du rendement Moy_ ZC100YR:
plt.figure(figsize=(10, 5))
plt.plot(data['Moy_ ZC100YR'], label='Moy_ ZC100YR')
plt.title('Graphique du rendement de obligations zero coupon de maturit√© 12 mois')
plt.xlabel('index')
plt.ylabel('Valeur')
plt.legend()
plt.grid(True)
plt.show()

"""### **On remarque clairement que les de rendement presentent des tendances**

### **REGRESSIONS LINEAIRES AVEC LA VARIABLE DEPENDANTE: Moy_ ZC025YR**
"""

# S√©lection des variables ind√©pendantes et de la variable d√©pendante
X_1 = data_mod[['Saison_Hiver','Saison_√ât√©', 'Saison_Printemps','Saison_Automne']].astype(int) # ajouter'T90_IAC', 'T10_IAC','P_IAC', 'D_IAC', 'WP90_IAC'
X_2 = data_mod[['IAC_CAN']]

X =pd.concat([X_1, X_2], axis=1)

y = data_mod['Moy_ ZC025YR'] # utiliser aussi 'S&P_TSX_Der'

# Ajout d'une constante √† X pour inclure l'intercept
X = sm.add_constant(X)

# Cr√©ation et ajustement du mod√®le de r√©gression lin√©aire OLS
model = sm.OLS(y, X)
results = model.fit()

# Affichage du r√©sum√© des r√©sultats du mod√®le
print(results.summary())

"""# Interpretation:
La r√©gression lin√©aire ordinaire utilis√©e pour analyser l'influence des saisons et de l'Indice actuariel climatique (IAC_CAN) sur la variable, rendemeent des obligations de maturit√© 3 mois (**Moy_ZC025YR**) r√©v√®le des coefficients significatifs pour toutes les variables saisonni√®res, indiquant des augmentations pendant les diff√©rentes saisons par rapport √† la moyenne annuelle, ainsi qu'un effet n√©gatif significatif de l'Indice Actuariel Climatique Canadien . Cependant, le mod√®le n'explique que 11.9% de la variabilit√© de **Moy_ZC025YR**, sugg√©rant que d'autres facteurs non inclus dans le mod√®le pourraient jouer un r√¥le.

Les diagnostics de r√©sidus montrent une violation de la normalit√©, ce qui pourrait compromettre la fiabilit√© des estimations des coefficients. Pour am√©liorer le mod√®le, il serait pertinent d'explorer l'inclusion d'autres variables explicatives, d'appliquer des transformations pour am√©liorer la normalit√© des r√©sidus, et d'envisager des mod√®les de volatilit√© ou des transformations de la variable d√©pendante pour mieux capturer la complexit√© des donn√©es. Des tests de robustesse pourraient √©galement √™tre r√©alis√©s pour √©valuer la stabilit√© des coefficients √† travers diff√©rentes sp√©cifications du mod√®le. Ces am√©liorations aideraient √† fournir des insights plus pr√©cis et √† am√©liorer la compr√©hension des dynamiques influen√ßant **Moy_ZC025YR**, crucial pour des applications pratiques telles que la planification financi√®re et l'analyse des risques li√©s aux changements climatiques.
"""

# S√©lection des variables ind√©pendantes et de la variable d√©pendante en tenant compte des composantes de IAC
X_1 = data_mod[['Saison_Hiver','Saison_√ât√©', 'Saison_Printemps','Saison_Automne']].astype(int) # ajouter'T90_IAC', 'T10_IAC','P_IAC', 'D_IAC', 'WP90_IAC'

X_2 = data_mod[['T90_IAC', 'T10_IAC','P_IAC', 'D_IAC', 'WP90_IAC','S_IAC']]
X =pd.concat([X_1, X_2], axis=1)

y = data_mod['Moy_ ZC025YR'] # utiliser aussi 'S&P_TSX_Der'

# Ajout d'une constante √† X pour inclure l'intercept
X = sm.add_constant(X)

# Cr√©ation et ajustement du mod√®le de r√©gression lin√©aire OLS
model = sm.OLS(y, X)
results = model.fit()

# Affichage du r√©sum√© des r√©sultats du mod√®le
print(results.summary())

"""# Interpretation:
Les r√©sultats de la r√©gression ordinaire montrent que le mod√®le, bien que seulement capable de capturer 15.6% de la variabilit√©, identifie des liens significatifs entre les effets saisonniers et certains indicateurs climatiques avec les valeurs des rendements des obligations zero coupon de maturit√© 3 mois. Toutes les saisons pr√©sentent des coefficients positifs, soulignant un impact notable sur les valeurs moyennes comparativement √† une ligne de base non sp√©cifi√©e. Parmi les variables climatiques, les tempertures extr√™mes basses (T10_IAC ) et le niveau de la mer (S_IAC) d√©montrent un impact significatif, indiquant une influence des conditions plus froides, tandis que P_IAC et D_IAC affichent des effets n√©gatifs, sugg√©rant que les p√©riodes de s√©cheresse ou de faibles pr√©cipitations sont associ√©es √† des diminutions de Moy_ ZC025YR.

Les indicateurs T90_IAC et WP90_IAC ne montrent pas de significativit√©, impliquant une absence d'effet clair des temp√©ratures √©lev√©es ou des pr√©cipitations intenses. Les tests de diagnostics r√©v√®lent des r√©sidus non normalement distribu√©s, posant des questions sur la fiabilit√© des estimations des coefficients. Pour am√©liorer la robustesse du mod√®le, il serait judicieux d'int√©grer des variables additionnelles, d'appliquer des transformations pour corriger la non-normalit√© des r√©sidus, ou d'explorer des mod√®les alternatifs tels que les mod√®les de volatilit√© pour traiter l'h√©t√©rosc√©dasticit√© observ√©e. Ce mod√®le offre une base pour des analyses plus approfondies, bien que son ajustement et sa pr√©cision n√©cessitent des am√©liorations substantielles.

### **REGRESSIONS LINEAIRES AVEC LA VARIABLE DEPENDANTE: Moy_ ZC050YR**
"""

# S√©lection des variables ind√©pendantes et de la variable d√©pendante
X_1 = data_mod[['Saison_Hiver','Saison_√ât√©', 'Saison_Printemps','Saison_Automne']].astype(int) # ajouter'T90_IAC', 'T10_IAC','P_IAC', 'D_IAC', 'WP90_IAC'
X_2 = data_mod[['IAC_CAN']]

X =pd.concat([X_1, X_2], axis=1)

y = data_mod['Moy_ ZC050YR'] #

# Ajout d'une constante √† X pour inclure l'intercept
X = sm.add_constant(X)

# Cr√©ation et ajustement du mod√®le de r√©gression lin√©aire OLS
model = sm.OLS(y, X)
results = model.fit()

# Affichage du r√©sum√© des r√©sultats du mod√®le
print(results.summary())

"""Les r√©sultats de la r√©gression lin√©aire OLS pour la variable Moy_ ZC050YR montrent une capacit√© modeste du mod√®le √† expliquer la variabilit√© de la variable d√©pendante avec un R-squared de 11.7% . Les coefficients pour les indicateurs saisonniers (hiver, √©t√©, printemps, automne) sont tous positifs et statistiquement significatifs, indiquant que chaque saison contribue positivement par rapport √† la ligne de base non saisonni√®re. De mani√®re int√©ressante, l'indice actuariel climatique (IAC_CAN) montre un effet n√©gatif significatif, sugg√©rant que des conditions climatiques mesur√©es par cet indice sont associ√©es √† une r√©duction de Moy_ ZC050YR. Les diagnostics indiquent que les r√©sidus ne sont pas normalement distribu√©s, ce qui peut affecter l'interpr√©tation des r√©sultats. La correction de cette non-normalit√©, potentiellement par des transformations ou des mod√®les plus complexes, pourrait am√©liorer la pr√©cision du mod√®le. L'am√©lioration du mod√®le pourrait √©galement impliquer l'exploration d'autres facteurs externes qui pourraient influencer Moy_ ZC050YR, ou l'utilisation de mod√®les de volatilit√© pour g√©rer l'h√©t√©rosc√©dasticit√© apparente des r√©sidus."""

# S√©lection des variables ind√©pendantes et de la variable d√©pendante Moy_ ZC075YR en tenant compte des composantes de IAC
X_1 = data_mod[['Saison_Hiver','Saison_√ât√©', 'Saison_Printemps','Saison_Automne']].astype(int) # ajouter'T90_IAC', 'T10_IAC','P_IAC', 'D_IAC', 'WP90_IAC'

X_2 = data_mod[['T90_IAC', 'T10_IAC','P_IAC', 'D_IAC', 'WP90_IAC','S_IAC']]

X =pd.concat([X_1, X_2], axis=1)

y = data_mod['Moy_ ZC050YR'] #

# Ajout d'une constante √† X pour inclure l'intercept
X = sm.add_constant(X)

# Cr√©ation et ajustement du mod√®le de r√©gression lin√©aire OLS
model = sm.OLS(y, X)
results = model.fit()

# Affichage du r√©sum√© des r√©sultats du mod√®le
print(results.summary())

"""### **REGRESSIONS LINEAIRES AVEC LA VARIABLE DEPENDANTE: Moy_ ZC075YR**"""

# S√©lection des variables ind√©pendantes et de la variable d√©pendante
X_1 = data_mod[['Saison_Hiver','Saison_√ât√©', 'Saison_Printemps','Saison_Automne']].astype(int) # ajouter'T90_IAC', 'T10_IAC','P_IAC', 'D_IAC', 'WP90_IAC'
X_2 = data_mod[['IAC_CAN']]

X =pd.concat([X_1, X_2], axis=1)

y = data_mod['Moy_ ZC075YR'] #

# Ajout d'une constante √† X pour inclure l'intercept
X = sm.add_constant(X)

# Cr√©ation et ajustement du mod√®le de r√©gression lin√©aire OLS
model = sm.OLS(y, X)
results = model.fit()

# Affichage du r√©sum√© des r√©sultats du mod√®le
print(results.summary())

# S√©lection des variables ind√©pendantes et de la variable d√©pendante Moy_ ZC075YR en tenant compte des composantes de IAC
X_1 = data_mod[['Saison_Hiver','Saison_√ât√©', 'Saison_Printemps','Saison_Automne']].astype(int) # ajouter'T90_IAC', 'T10_IAC','P_IAC', 'D_IAC', 'WP90_IAC'

X_2 = data_mod[['T90_IAC', 'T10_IAC','P_IAC', 'D_IAC', 'WP90_IAC','S_IAC']]

X =pd.concat([X_1, X_2], axis=1)

y = data_mod['Moy_ ZC075YR'] #

# Ajout d'une constante √† X pour inclure l'intercept
X = sm.add_constant(X)

# Cr√©ation et ajustement du mod√®le de r√©gression lin√©aire OLS
model = sm.OLS(y, X)
results = model.fit()

# Affichage du r√©sum√© des r√©sultats du mod√®le
print(results.summary())

"""### **REGRESSIONS LINEAIRES AVEC LA VARIABLE DEPENDANTE: Moy_ ZC100YR**"""

# S√©lection des variables ind√©pendantes et de la variable d√©pendante
X_1 = data_mod[['Saison_Hiver','Saison_√ât√©', 'Saison_Printemps','Saison_Automne']].astype(int) # ajouter'T90_IAC', 'T10_IAC','P_IAC', 'D_IAC', 'WP90_IAC'
X_2 = data_mod[['IAC_CAN']]

X =pd.concat([X_1, X_2], axis=1)

y = data_mod['Moy_ ZC100YR'] #

# Ajout d'une constante √† X pour inclure l'intercept
X = sm.add_constant(X)

# Cr√©ation et ajustement du mod√®le de r√©gression lin√©aire OLS
model = sm.OLS(y, X)
results = model.fit()

# Affichage du r√©sum√© des r√©sultats du mod√®le
print(results.summary())

# S√©lection des variables ind√©pendantes et de la variable d√©pendante Moy_ ZC100YR en tenant compte des composantes de IAC
X_1 = data_mod[['Saison_Hiver','Saison_√ât√©', 'Saison_Printemps','Saison_Automne']].astype(int) # ajouter'T90_IAC', 'T10_IAC','P_IAC', 'D_IAC', 'WP90_IAC'

X_2 = data_mod[['T90_IAC', 'T10_IAC','P_IAC', 'D_IAC', 'WP90_IAC','S_IAC']]

X =pd.concat([X_1, X_2], axis=1)

y = data_mod['Moy_ ZC100YR'] #

# Ajout d'une constante √† X pour inclure l'intercept
X = sm.add_constant(X)

# Cr√©ation et ajustement du mod√®le de r√©gression lin√©aire OLS
model = sm.OLS(y, X)
results = model.fit()

# Affichage du r√©sum√© des r√©sultats du mod√®le
print(results.summary())

"""**# INTERPRETATION ET COMMENTAIRE: Choix de Moy_ ZC025YR pour la suite : meilleure R carr√©.m√´me conclusion pour les autres. les mettre en annexe**

# **ANALYSE AVEC LE MOD√àLE ARMA**
"""

print(data_mod.keys())

"""# **IDENTIFICATION DE L'ODRE DE AR ET MA**"""

# V√©rification de la stationnarit√© de S&P_TSX_Der

result = adfuller(data['Moy_ ZC050YR'])
print('ADF Statistic:', result[0])
print('p-value:', result[1])

"""### La p-value est > 0.05 alors la s√©rie des prix de l'indice boursier n'est pas stationnaire, nous avons besoin de la diff√©rencier"""

# DIFFERENCTIATION

data['Moy_ ZC025YR_diff'] = data['Moy_ ZC025YR'].diff().dropna()

#Suppression des nan √† nouveau
data=data.dropna()

# Identification des param√®tres p et q : ici nous devons analyser le graohe des autocorrelation et des autocorrelations partielles

fig, axes = plt.subplots(1, 2, figsize=(15,4))
plot_acf(data['Moy_ ZC025YR_diff'].dropna(), ax=axes[0])
plot_pacf(data['Moy_ ZC025YR_diff'].dropna(), ax=axes[1], method='ywm')
plt.show()

"""**#Interpretations:**
Les graphiques d'autocorr√©lation (ACF) et d'autocorr√©lation partielle (PACF) pr√©sent√©s ici offrent des indications sur la structure temporelle des donn√©es de taux de rendement des obligations zero coupon que vous √©tudiez. Voici une analyse d√©taill√©e de ce que ces graphiques nous r√©v√®lent :

Autocorr√©lation (ACF): L'ACF montre une d√©croissance significative initiale suivie de valeurs qui s'att√©nuent rapidement vers z√©ro, ce qui est typique des s√©ries qui ont √©t√© diff√©renci√©es ou qui pr√©sentent une certaine forme de d√©pendance √† court terme. Cela sugg√®re que le mod√®le peut n√©cessiter une composante AR pour capter cette autocorr√©lation initiale.

Autocorr√©lation Partielle (PACF): La PACF montre un pic significatif au premier lag, puis les valeurs tombent rapidement vers z√©ro et restent dans la zone de non-significativit√© pour les lags suivants. Ce comportement est caract√©ristique d'un mod√®le potentiellement AR(1), o√π seulement le premier lag est pertinent pour pr√©dire les valeurs futures de la s√©rie.

Recommandations pour la mod√©lisation :
Mod√®le ARIMA: √âtant donn√© le comportement observ√© dans l'ACF et le PACF, un mod√®le ARIMA(1,1,0) pourrait √™tre appropri√©. Le premier terme AR aiderait √† capter l'autocorr√©lation √† court terme, et la diff√©renciation premi√®re est d√©j√† indiqu√©e par la nature des donn√©es diff√©renci√©es.

V√©rification de la stationnarit√©: Il serait prudent de r√©aliser un test de stationnarit√© (comme le test ADF) pour confirmer que la s√©rie diff√©renci√©e est bien stationnaire.

Validation du mod√®le: Apr√®s ajustement, il est crucial de v√©rifier les r√©sidus du mod√®le ARIMA pour s'assurer qu'ils ressemblent √† un bruit blanc, indiquant que le mod√®le a bien captur√© toute l'information dans les donn√©es.

Ces analyses et ajustements vous aideront √† mieux comprendre et pr√©dire les comportements des taux de rendement, ce qui est essentiel pour la gestion de risque et la planification d'investissement dans des obligations zero coupon.
"""

plt.figure(figsize=(10, 5))
plt.plot(data['Moy_ ZC025YR_diff'], label='Moy_ ZC025YR_diff')
plt.title('Graphique de differentiation des taux de rendements des obligations zero coupon de maturit√© 3mois')
plt.xlabel('index')
plt.ylabel('Valeur')
plt.legend()
plt.grid(True)
plt.show()

"""# **Interpretation :**
Ce graphique montre la diff√©renciation des taux de rendements des obligations z√©ro coupon de maturit√© 3 mois. La s√©rie temporelle affiche des fluctuations autour de z√©ro, mais des variations restent cependant notables, avec des pics significatifs qui sugg√®rent des r√©actions √† des √©v√©nements ou des annonces √©conomiques sp√©cifiques.

Analyse et suggestions pour la mod√©lisation :
Stationnarit√©: Comme pour la s√©rie pr√©c√©dente, la diff√©renciation semble aider √† atteindre une stationnarit√©, essentielle pour les mod√®les ARIMA. Il serait prudent de confirmer cette stationnarit√© √† l'aide de tests statistiques formels comme le test ADF.

Mod√©lisation de la volatilit√©: Bien que moins extr√™me, la volatilit√© observ√©e peut b√©n√©ficier de mod√®les de volatilit√© conditionnelle tels que GARCH pour mieux capturer les variations dans le temps et fournir des pr√©visions de volatilit√© plus pr√©cises.

D√©pendance temporelle: L'analyse des autocorr√©lations devrait √™tre entreprise pour d√©terminer l'ordre appropri√© des composants AR et MA dans un mod√®le ARIMA ou SARIMAX, en tenant compte des saisons si des cycles sp√©cifiques sont observ√©s √† travers les donn√©es.

Validation de mod√®le: Une fois le mod√®le ajust√©, il est crucial d'analyser les r√©sidus pour v√©rifier qu'ils ne montrent aucune structure syst√©matique (c'est-√†-dire qu'ils sont proches du bruit blanc), ce qui indiquerait que le mod√®le capture bien la dynamique de la s√©rie.

Comparaison inter-s√©ries: Comparer les comportements de diff√©rentes s√©ries de maturit√©s pourrait √©galement r√©v√©ler des insights int√©ressants sur la mani√®re dont les attentes du march√© varient avec la dur√©e jusqu'√† la maturit√© des obligations.

Cette analyse contribue √† une compr√©hension plus compl√®te des mouvements de taux sur le march√© des obligations z√©ro coupon et aide √† formuler des strat√©gies de gestion de portefeuille bas√©es sur des pr√©visions de taux plus inform√©es.

"""

# CONSTRUCTION DU MODELE ARMAX AVEC ORDRE DE DIFFERENCIATION 0


from statsmodels.tsa.statespace.sarimax import SARIMAX

model = SARIMAX(data['Moy_ ZC025YR_diff'],exog=data['IAC_CAN'],
                order=(2, 0, 1),  # (p, d, q) o√π p est l'ordre AR, d est l'ordre de diff√©renciation, q l'ordre MA
                enforce_stationarity=False,enforce_invertibility=False)

# Ajustement du mod√®le
results = model.fit()

# Affichage du r√©sum√© du mod√®le
print(results.summary())

# Analyses des r√©sidus .
results.plot_diagnostics(figsize=(15, 12))
plt.show()

"""### **COMMENTAIRES ET INTERPRETATIONS DES STATISTIQUES :**

Les r√©sultats du mod√®le SARIMAX(2,0,1) appliqu√© √† la s√©rie des taux de rendement des obligations zero coupon montrent certains points int√©ressants et des zones potentielles de pr√©occupation :

Param√®tres AR et MA : Le mod√®le inclut deux termes autor√©gressifs (AR) et un terme de moyenne mobile (MA). Les coefficients pour ar.L1 et ar.L2 sont significatifs, indiquant que les valeurs pass√©es influencent directement les valeurs actuelles, avec des p-values bien en dessous de 0.05. En revanche, le terme ma.L1 a un coefficient extr√™mement √©lev√© (5.0675), ce qui est inhabituel et pourrait indiquer un probl√®me de sp√©cification ou de convergence du mod√®le.

Insignifiance de IAC_CAN : Le coefficient pour IAC_CAN est proche de z√©ro (0.0003) et n'est pas statistiquement significatif (p-value de 0.309), ce qui sugg√®re que cette variable explicative n'a pas d'impact significatif sur les variations des taux de rendement dans ce mod√®le.

Diagnostiques des r√©sidus :

Ljung-Box test : Le test indique une p-value de 0.88, sugg√©rant que les r√©sidus du mod√®le n'ont pas d'autocorr√©lation significative √† un lag sp√©cifique, ce qui est un bon signe d'ad√©quation du mod√®le.
Test de Jarque-Bera : Avec une p-value de 0.00, ce test indique que les r√©sidus ne suivent pas une distribution normale, ce qui est pr√©occupant pour les hypoth√®ses classiques de la r√©gression OLS.
H√©t√©rosc√©dasticit√© : Le test indique une h√©t√©rosc√©dasticit√© significative (p-value de 0.00), avec une valeur tr√®s faible pour le rapport de h√©t√©rosc√©dasticit√©, indiquant une variation in√©gale des r√©sidus √† travers le temps.

### **CONCLUSION ET RECOMMANDATIONS :**
Bien que le mod√®le capte certains aspects des dynamiques temporelles des taux de rendement, les probl√®mes de non-normalit√© des r√©sidus et d'h√©t√©rosc√©dasticit√© soul√®vent des questions sur l'ad√©quation globale du mod√®le. Il serait b√©n√©fique de :

Revoir les sp√©cifications du mod√®le, peut-√™tre en explorant des transformations des variables ou l'ajout d'autres termes explicatifs.
Consid√©rer l'utilisation de mod√®les robustes aux anomalies de distribution des r√©sidus, tels que les mod√®les avec des erreurs GARCH ou EGARCH.
Continuer √† surveiller la performance du mod√®le avec de nouvelles donn√©es pour ajuster et am√©liorer le mod√®le au fil du temps.

### **COMMENTAIRES ET INTERPRETATIONS DES GRAPHIQUES :**


**Le graphique des R√©sidus Standardis√©s** montrent des pics significatifs, indiquant des √©carts par rapport √† la moyenne qui ne sont pas captur√©s par le mod√®le. Cette variabilit√© excessive peut √™tre le signe de chocs ou de variations non pris en compte dans le mod√®le actuel.

**L'histogramme des r√©sidus** montre que les r√©sidus ne suivent pas une distribution normale, comme le montre √©galement l'ajustement de la courbe de densit√© (KDE) par rapport √† la ligne de la distribution normale (N(0,1)). Cela indique des probl√®mes de normalit√© avec des queues lourdes et potentiellement des donn√©es asym√©triques.


 **Le graphique Q-Q**  montre une d√©viation notable des quantiles th√©oriques par rapport aux quantiles de l'√©chantillon, surtout dans les extr√©mit√©s de la distribution, sugg√©rant la pr√©sence de valeurs extr√™mes ou d'outliers. Cela remet en question l'ad√©quation de la distribution normale pour ces r√©sidus.


 **Le correlogramme** r√©v√®le que l'autocorr√©lation pour les premiers d√©calages est significativement √©lev√©e, ce qui pourrait indiquer que le mod√®le n'a pas enti√®rement captur√© la dynamique temporelle des donn√©es. Les d√©calages subs√©quents semblent tomber dans la bande de non-significativit√©, ce qui est un signe positif de l'efficacit√© du mod√®le √† ces d√©calages.

 Les diagnostics indiquent que le mod√®le SARIMAX pourrait n√©cessiter des ajustements pour am√©liorer sa sp√©cification. L'absence de normalit√© et la pr√©sence d'autocorr√©lations r√©siduelles sugg√®rent que d'autres transformations des donn√©es ou l'ajout de composants suppl√©mentaires comme un mod√®le GARCH pour les variances conditionnelles pourraient √™tre n√©cessaires. L'ajustement pour mieux g√©rer les valeurs aberrantes et les p√©riodes de volatilit√© accrue pourrait √©galement am√©liorer les performances du mod√®le. Ces ajustements aideront √† obtenir des pr√©visions plus pr√©cises et √† mieux comprendre les dynamiques sous-jacentes des taux de rendement observ√©s.

**Les diagnostics indiquent que le mod√®le SARIMAX pourrait n√©cessiter des ajustements pour am√©liorer sa sp√©cification. L'absence de normalit√© et la pr√©sence d'autocorr√©lations r√©siduelles sugg√®rent que d'autres transformations des donn√©es ou l'ajout de composants suppl√©mentaires comme un mod√®le GARCH pour les variances conditionnelles pourraient √™tre n√©cessaires. L'ajustement pour mieux g√©rer les valeurs aberrantes et les p√©riodes de volatilit√© accrue pourrait √©galement am√©liorer les performances du mod√®le. Ces ajustements aideront √† obtenir des pr√©visions plus pr√©cises et √† mieux comprendre les dynamiques sous-jacentes des taux de rendement observ√©s.**

# **QUELQUES AM√âLIORATIONS DU MOD√àLE ARMA PRECEDENT**



### *   **Examen de la stabilit√© des param√®tres dans le temps.**
"""

# l'examen de la stabilit√© des param√®tres dans le temps.
# Affichage des r√©sidus
plt.figure(figsize=(12, 6))
plt.plot(results.resid, label='R√©sidus')
plt.title('R√©sidus du mod√®le SARIMAX')
plt.legend()
plt.show()

"""### Les r√©sidus du mod√®le SARIMAX, tels qu'ils apparaissent sur le graphique, montrent une fluctuation autour de z√©ro, indiquant qu'il n'y a pas de biais syst√©matique significatif dans les pr√©dictions du mod√®le. La plupart des r√©sidus semblent √™tre contenus dans une bande √©troite, ce qui est un bon signe de la capacit√© du mod√®le √† capturer une grande partie de l'information dans les donn√©es. Cependant, les pics sporadiques, notamment les excursions plus grandes que les autres observ√©es, pourraient indiquer des anomalies ou des chocs externes que le mod√®le actuel ne parvient pas √† capturer pleinement.
###Ces pics pourraient signaler la pr√©sence de volatilit√© non expliqu√©e, ce qui pourrait √™tre une indication pour examiner plus en d√©tail les mod√®les de volatilit√© conditionnelle comme GARCH, ou pour int√©grer des variables explicatives suppl√©mentaires qui pourraient expliquer ces variations. En outre, il pourrait √™tre utile de tester la stationnarit√© des r√©sidus pour s'assurer qu'il ne reste pas de tendances ou de cycles non captur√©s par le mod√®le actuel. Un examen plus approfondi des p√©riodes correspondant aux grands r√©sidus pourrait √©galement r√©v√©ler des dynamiques sp√©cifiques ou des √©v√©nements qui n√©cessitent un ajustement du mod√®le ou une mod√©lisation s√©par√©e.
"""

# Affichage de la variance roulante des r√©sidus pour voir la stabilit√© de la variance
rolling_var = results.resid.rolling(window=12).var()
plt.figure(figsize=(15, 6))
plt.plot(rolling_var, label='Variance roulante des r√©sidus')
plt.title('Variance roulante des r√©sidus')
plt.legend()
plt.show()

"""La variance roulante des r√©sidus illustre des p√©riodes de volatilit√© variable dans les donn√©es analys√©es. La pr√©sence de pics significatifs √† certains points sugg√®re des √©pisodes o√π les variations des taux de rendements des obligations sont plus impr√©visibles et pourraient signaler des √©v√©nements externes ou des changements dans les dynamiques du march√© non captur√©s par le mod√®le SARIMAX actuel.

Ces variations accentu√©es de la variance indiquent que le mod√®le pourrait b√©n√©ficier de l'int√©gration d'un mod√®le GARCH pour mod√©liser et pr√©voir cette volatilit√© conditionnelle. De telles am√©liorations permettraient de mieux comprendre et anticiper les p√©riodes de turbulences sur le march√©, offrant ainsi une mod√©lisation plus robuste et des pr√©dictions am√©lior√©es pour la gestion du risque et la prise de d√©cision strat√©gique en finance.
"""

#TEST DE WHITE
from statsmodels.stats.diagnostic import het_white

# Pr√©parer les donn√©es pour le test de White
residus = results.resid
exog = data[['IAC_CAN']]  # Utilisez les m√™mes variables exog√®nes que dans votre mod√®le
exog_const = sm.add_constant(exog)  # Ajouter une constante aux variables explicatives pour le test

# Effectuer le test de White sur les r√©sidus
test_stat, p_value, f_stat, f_p_value = het_white(residus, exog_const)

# Afficher les r√©sultats du test de White
print("Statistique du test de White:", test_stat)
print("P-value du test de White:", p_value)
print("Statistique F:", f_stat)
print("P-value du F-test:", f_p_value)

"""### ***Avec ces valeurs de p-value la pr√©sence d'h√©t√©rosc√©dasticit√© dans les r√©sidus est confirm√©e et signifie que les estimations standards des erreurs des coefficients du mod√®le sont biais√©es, ce qui peut mener √† des conclusions erron√©es concernant la significativit√© des variables du mod√®le.***

En effet

Les r√©sultats du test de White indiquent une pr√©sence significative d'h√©t√©rosc√©dasticit√© dans les r√©sidus du mod√®le analys√©. La statistique du test est de 7.944 avec une p-value de 0.0188, et la statistique F est de 4.017 avec une p-value de 0.0187. Ces valeurs sugg√®rent que les variations de la variance des erreurs ne sont pas al√©atoires mais plut√¥t li√©es √† des variables ou des structures non captur√©es dans le mod√®le actuel.

Cela pourrait signaler que certains facteurs explicatifs ou dynamiques de s√©rie temporelle influencent la variance de fa√ßon syst√©matique, rendant n√©cessaire l'ajustement du mod√®le initial ou l'adoption de mod√®les plus complexes comme les mod√®les GARCH pour traiter la volatilit√© conditionnelle, ou encore la r√©vision des variables explicatives pour mieux mod√©liser la variation des donn√©es et am√©liorer la robustesse des pr√©dictions.

"""

#TEST  de Breusch-Pagan

from statsmodels.stats.diagnostic import het_breuschpagan

# Variables exog√®nes utilis√©es dans le mod√®le
# Nous devons inclure une constante dans les variables exog√®nes pour le test
exog = sm.add_constant(data[['IAC_CAN']])

# Effectuer le test de Breusch-Pagan
bp_test = het_breuschpagan(residus, exog)

# Afficher les r√©sultats du test de Breusch-Pagan
bp_stat, bp_pvalue, fvalue, fpvalue = bp_test
print("Statistique de Breusch-Pagan :", bp_stat)
print("P-value de Breusch-Pagan :", bp_pvalue)
print("Statistique F :", fvalue)
print("P-value du F-test :", fpvalue)

"""### ***Les r√©sultats du test de Breusch-Pagan confirment la pr√©sence d'h√©t√©rosc√©dasticit√© dans les r√©sidus de notre mod√®le, sugg√©rant la n√©cessit√© de r√©viser le mod√®le ou d'adopter des techniques qui prennent en compte cette variance non constante pour am√©liorer la pr√©cision et la validit√© des analyses.***"""

# CONSTRUCTION DU MODELE ARIMA ARMAX AVEC ORDRE DE DIFFERENCIATION 1
from statsmodels.tsa.statespace.sarimax import SARIMAX

model_2 = SARIMAX(data['Moy_ ZC025YR_diff'],
                exog=data['IAC_CAN'],
                order=(2, 1, 1),  # (p, d, q) o√π p est l'ordre AR, d est l'ordre de diff√©renciation, q l'ordre MA
                enforce_stationarity=False,
                enforce_invertibility=False)

# Ajuster le mod√®le
results_2 = model_2.fit()

# Afficher le r√©sum√© du mod√®le
print(results_2.summary())

# Diagnostics pour v√©rifier les r√©sidus etc.
results_2.plot_diagnostics(figsize=(15, 12))
plt.show()

"""### ***Le mod√®le SARIMAX(1, 1, 1) presente des conclusions moindres que le mod√®le SARIMAX(1, 0, 1)***


"""

pip install arch

## MODELE GARCHE POUR RESIDU DE SARIMX(2,0,1)

from arch import arch_model

# Cr√©ation du mod√®le GARCH
garch = arch_model(residus, p=1, q=1)  # Mod√®le GARCH(1,1)
results_garch = garch.fit(update_freq=3)
print(results_garch.summary())

"""## **INTERPRESTATION ET COMMENTAIRE :**

Les r√©sultats du mod√®le GARCH(1,1) pour la s√©rie analys√©e montrent que la constante moyenne (mu) est extr√™mement pr√©cise avec une valeur de **0.2099**, pr√©sentant une tr√®s faible erreur standard et une t-value extr√™mement √©lev√©e, ce qui sugg√®re une forte stabilit√© de cette estimation √† travers le mod√®le. Toutefois, les param√®tres du mod√®le de volatilit√©, **alpha[1]** et **beta[1]**, montrent des incertitudes significatives avec des valeurs t et des intervalles de confiance qui ne permettent pas d'affirmer leur significativit√© statistique.

**Alpha**, avec une valeur de **0.100** et une p-value de **0.761**, et beta, avec une valeur de **0.880** et une p-value de **0.116**, ne sont pas statistiquement significatifs, ce qui met en question la capacit√© du mod√®le √† capturer efficacement la dynamique de la volatilit√© des donn√©es. Cela peut indiquer que le mod√®le pourrait n√©cessiter une r√©vision des param√®tres ou l'utilisation d'autres formes de mod√®les de volatilit√© qui pourraient mieux s'adapter aux caract√©ristiques des donn√©es observ√©es.

Pour am√©liorer la mod√©lisation, il pourrait √™tre judicieux d'explorer des mod√®les avec diff√©rentes sp√©cifications de volatilit√©, tels que EGARCH ou GARCH avec des distributions autres que la normale, ou d'augmenter le nombre de lags dans les composantes alpha et beta pour voir si une structure plus complexe pourrait mieux capturer les dynamiques observ√©es.

"""

## MODELE GARCHE POUR RESIDU DE SARIMX(2,1,1)

from arch import arch_model
residus_2 = results_2.resid
# Cr√©ation du mod√®le GARCH
garch_2 = arch_model(residus_2, p=1, q=1)  # Mod√®le GARCH(1,1)
results_garch_2 = garch_2.fit(update_freq=3)
print(results_garch_2.summary())

"""### **Les conclusions de GARCH(1,1) sur les residus de SARIMAX(2,0,1) sont identiques, voire meilleurs que celui de  de GARCH(1,1) sur les residus de SARIMAX(2,1,1)**"""

# Cr√©ation du mod√®le EGARCH avec distribution normale
egarch_model = arch_model(residus, vol='EGARCH', p=1, q=1)

egarch_results = egarch_model.fit(update_freq=3)
print(egarch_results.summary())

"""## **INTERPRESTATION ET COMMENTAIRE :**

Les r√©sultats du mod√®le **EGARCH(1,1)** pr√©sentent des estimations statistiquement significatives pour le terme moyen **Œº** et les param√®tres de volatilit√© **Œ±[1]** et **Œ≤[1]**. Le terme **Œº**, avec une valeur exceptionnellement pr√©cise de **8.2762**, est significatif, indiquant une contribution constante √† la s√©rie temporelle. L'omega n√©gatif √† **-2.9009** sugg√®re une r√©activit√© inverse entre la volatilit√© et les innovations pr√©c√©dentes, typique des mod√®les **EGARCH** o√π la volatilit√© peut √™tre influenc√©e asym√©triquement par les chocs pass√©s.

Le param√®tre **Œ±[1]**, significatif, montre l'impact des chocs pr√©c√©dents sur la volatilit√© actuelle, tandis que le **Œ≤[1]** tr√®s √©lev√© et significatif indique une persistance √©lev√©e de la volatilit√©. Ces r√©sultats sugg√®rent que le mod√®le capte bien les dynamiques de la volatilit√©, mais l'extr√™me magnitude des valeurs log-likelihood et AIC indique potentiellement des probl√®mes de mod√©lisation ou d'√©chelle des donn√©es qui pourraient n√©cessiter un ajustement ou une validation suppl√©mentaire pour s'assurer de la robustesse du mod√®le EGARCH utilis√©.





**Le mod√®le EGARCH ajust√© avec la distribution de normale fournit une analyse robuste de la volatilit√©, en capturant efficacement la nature des extr√™mes et en offrant une bonne compr√©hension de la persistance et de la r√©activit√© de la volatilit√©. La non-significativit√© de certains param√®tres sugg√®re d'autres investigations ou ajustements.**
"""

# Cr√©ation du mod√®le EGARCH avec distribution de student

egarch_model = arch_model(residus, vol='EGARCH', p=1, q=1,dist='t')

egarch_results = egarch_model.fit(update_freq=3)
print(egarch_results.summary())

"""## **INTERPRESTATION ET COMMENTAIRE :**

Les r√©sultats du mod√®le EGARCH ajust√© avec une distribution des erreurs de Student montrent une pr√©cision remarquable pour l'estimation du terme moyen
ùúá, indiquant une influence constante notable sur la s√©rie temporelle. Cependant, les param√®tres de volatilit√© r√©v√®lent des anomalies dans les estimations: l'omega affiche une valeur n√©gative non significative, ce qui est habituel pour un mod√®le EGARCH indiquant que les chocs n√©gatifs affectent plus la volatilit√© que les chocs positifs, mais sa non-significativit√© sugg√®re une faible influence.

L'alpha, bien que pr√©sentant un effet extr√™mement grand et significatif, est probablement un artefact num√©rique d√ª √† des probl√®mes de convergence ou d'√©chelle des donn√©es. Le beta √† z√©ro et non significatif indique une absence de persistance dans les effets des chocs pr√©c√©dents sur la volatilit√© future, ce qui est inhabituel et sugg√®re des probl√®mes sous-jacents dans la sp√©cification du mod√®le ou des donn√©es.

Le param√®tre de degr√©s de libert√© ùúà pour la distribution de Student est non significatif, sugg√©rant que l'ajout de cette distribution n'am√©liore pas significativement la mod√©lisation des queues de distribution par rapport √† une distribution normale. Ce mod√®le n√©cessite une r√©√©valuation et potentiellement une reformulation pour assurer une mod√©lisation robuste et interpr√©table de la volatilit√© des rendements observ√©s.
"""